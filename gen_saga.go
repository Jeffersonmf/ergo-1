package ergo

import (
	"fmt"
	"time"

	"github.com/halturin/ergo/etf"
	"github.com/halturin/ergo/lib"
)

type GenSaga struct {
	GenServer
}

type GenSagaTransactionOptions struct {
	// Name defines the name of this transaction. By default
	// this name has autogenerated ID.
	Name string
	// HopLimit defines a number of hop within the transaction. Default limit
	// is 0 (no limit).
	HopLimit uint
	// Deadline defines
	Deadline uint

	// TwoPhaseCommit enables 2PC for the transaction. This option makes
	// Saga-initiator emit a 'commit' message (once the final result is received)
	// for all participants (other Sagas) in this transaction and invokes HandleCommit
	// if they implement this method.
	TwoPhaseCommit bool
}

type GenSagaOptions struct {
	// MaxTransactions defines the limit for the number of active transactions. Default: 0 (unlimited)
	MaxTransactions uint
}

type GenSagaState struct {
	GenServerState
	Options GenSagaOptions
	txs     map[string]GenSagaTransaction
}

type GenSagaTransaction struct {
	ID        string
	StartTime int64
	Options   GenSagaTransactionOptions
	Ref       etf.Ref
	Parents   []etf.Pid
	timer     time.Timer
}

type GenSagaNext struct {
	// Next - etf.Pid, string (for the locally registered process), etf.Tuple{process, node} (for the remote one)
	Next interface{}
	// Value - a value for the invoking HandleNext on a Next hop.
	Value interface{}
	// Timeout - how long this Saga will be waiting for the result from the Next hop. Default - 10 seconds
	Timeout uint
}

type sagaMessage struct {
	Request string
	Command interface{}
}

type sagaMessageNext struct {
	Transaction GenSagaTransaction
	Value       interface{}
}

type sagaMessageResult struct {
	Transaction GenSagaTransaction
	From        etf.Pid
	Result      interface{}
}

type sagaMessageCancel struct {
	Transaction GenSagaTransaction
	From        etf.Pid
	Reason      string
}

// GenSagaBehavior interface
type GenSagaBehavior interface {
	//
	// Mandatory callbacks
	//

	// InitSaga
	InitSaga(state *GenSagaState, args ...interface{}) error

	// HandleNext
	HandleNext(state *GenSagaState, tx GenSagaTransaction, value interface{}) error

	// HandleCancel invoked on a request of transaction cancelation.
	HandleCancel(state *GenSagaState, tx GenSagaTransaction, reason string) error

	// HandleResult
	HandleResult(state *GenSagaState, tx GenSagaTransaction, next GenSagaNext, result interface{}) error

	// HandleTimeout
	HandleTimeout(state *GenSagaState, tx GenSagaTransaction, next GenSagaNext) error

	//
	// Optional callbacks
	//

	// HandleInterim invoked if received interim result from the Next hop
	HandleInterim(state *GenSagaState, tx GenSagaTransaction, next GenSagaNext, interim interface{}) error
	// HandleCommit invoked if TwoPhaseCommit is enabled on the given transaction
	HandleCommit(state *GenSagaState, tx GenSagaTransaction)

	// HandleGenStageCall this callback is invoked on Process.Call. This method is optional
	// for the implementation
	HandleGenSagaCall(state *GenSagaState, from GenServerFrom, message etf.Term) (string, etf.Term)
	// HandleGenStageCast this callback is invoked on Process.Cast. This method is optional
	// for the implementation
	HandleGenSagaCast(state *GenSagaState, message etf.Term) string
	// HandleGenStageInfo this callback is invoked on Process.Send. This method is optional
	// for the implementation
	HandleGenSagaInfo(state *GenSagaState, message etf.Term) string
}

// API

func (gs *GenSaga) StartTransaction(process *Process, options GenSagaTransactionOptions, next GenSagaNext) (error, etf.Ref) {
	if options.Name == "" {
		options.Name = lib.RandomString(32)
	}

	tx := GenSagaTransaction{
		ID:        options.Name,
		Options:   options,
		StartTime: time.Now().Unix(),
		Ref:       process.Node.MakeRef(),
	}

	return nil, tx.Ref
}

// default GenSaga callbacks

func (gs *GenSaga) HandleInterim(state *GenSagaState, tx GenSagaTransaction, interim interface{}) error {
	// default callback if it wasn't implemented
	fmt.Printf("HandleInterim: unhandled message %#v\n", tx)
	return nil
}

func (gs *GenSaga) HandleCommit(state *GenSagaState, tx GenSagaTransaction) {
	return
}

func (gs *GenSaga) HandleGenSagaCall(state *GenSagaState, from GenServerFrom, message etf.Term) (string, etf.Term) {
	// default callback if it wasn't implemented
	fmt.Printf("HandleGenSagaCall: unhandled message (from %#v) %#v\n", from, message)
	return "reply", etf.Atom("ok")
}

func (gs *GenSaga) HandleGenSagaCast(state *GenSagaState, message etf.Term) string {
	// default callback if it wasn't implemented
	fmt.Printf("HandleGenSagaCast: unhandled message %#v\n", message)
	return "noreply"
}
func (gs *GenSaga) HandleGenSagaInfo(state *GenSagaState, message etf.Term) string {
	// default callback if it wasn't implemnted
	fmt.Printf("HandleGenSagaInfo: unhandled message %#v\n", message)
	return "noreply"
}

//
// GenServer callbacks
//
func (gs *GenSaga) Init(state *GenServerState, args ...interface{}) error {
	sagaState := &GenSagaState{
		GenServerState: *state,
	}
	if err := state.Process.GetObject().(GenSagaBehavior).InitSaga(sagaState, args...); err != nil {
		return err
	}
	state.State = sagaState
	return nil
}

func (gs *GenSaga) HandleCall(state *GenServerState, from GenServerFrom, message etf.Term) (string, etf.Term) {
	st := state.State.(*GenSagaState)

	switch m := message.(type) {
	case sagaMessageNext:
		if st.Options.MaxTransactions > 0 && len(st.txs) >= int(st.Options.MaxTransactions) {
			return "reply", "overload"
		}

		if m.Transaction.ID == "" {
			return "reply", "wrong_tx_id"
		}

		if _, exist := st.txs[m.Transaction.ID]; exist {
			return "reply", "loop_detected"
		}

		if m.Transaction.Options.HopLimit > 0 &&
			len(m.Transaction.Parents) > int(m.Transaction.Options.HopLimit) {
			return "reply", "exceeded_hop_limit"
		}

		// everything looks good. we can go further
		msg := sagaMessage{
			Request: "$saga_next",
			Command: m,
		}
		state.Process.Send(state.Process.Self(), msg)
		return "reply", "ok"
	default:
		return state.Process.GetObject().(GenSagaBehavior).HandleGenSagaCall(st, from, message)
	}
}

func (gs *GenSaga) HandleCast(state *GenServerState, message etf.Term) string {
	st := state.State.(*GenSagaState)
	return state.Process.GetObject().(GenSagaBehavior).HandleGenSagaCast(st, message)
}

func (gs *GenSaga) HandleInfo(state *GenServerState, message etf.Term) string {
	var m sagaMessage

	st := state.State.(*GenSagaState)
	// check if we got a 'DOWN' message
	// {DOWN, Ref, process, PidOrName, Reason}
	if isDown, d := IsDownMessage(message); isDown {
		if err := handleSagaDown(st, d); err != nil {
			return err.Error()
		}
		return "noreply"
	}

	if err := etf.TermIntoStruct(message, &m); err != nil {
		reply := state.Process.GetObject().(GenSagaBehavior).HandleGenSagaInfo(st, message)
		return reply
	}

	err := handleSagaRequest(st, m)
	switch err {
	case nil:
		return "noreply"
	case ErrStop:
		return "stop"
	case ErrUnsupportedRequest:
		reply := state.Process.GetObject().(GenSagaBehavior).HandleGenSagaInfo(st, message)
		return reply
	default:
		return err.Error()
	}
}

func handleSagaRequest(state *GenSagaState, m sagaMessage) error {
	var nextMessage sagaMessageNext
	var cancel sagaMessageCancel
	var result sagaMessageResult

	next := GenSagaNext{}
	switch m.Request {
	case "$saga_next":
		if err := etf.TermIntoStruct(m.Command, &nextMessage); err != nil {
			return ErrUnsupportedRequest
		}
		state.Process.GetObject().(GenSagaBehavior).HandleNext(state, nextMessage.Transaction, next.Value)
		return nil
	case "$saga_cancel":
		if err := etf.TermIntoStruct(m.Command, &cancel); err != nil {
			return ErrUnsupportedRequest
		}
		state.Process.GetObject().(GenSagaBehavior).HandleCancel(state, cancel.Transaction, cancel.Reason)
		return nil
	case "$saga_interim":
		if err := etf.TermIntoStruct(m.Command, &result); err != nil {
			return ErrUnsupportedRequest
		}
		state.Process.GetObject().(GenSagaBehavior).HandleInterim(state, result.Transaction, next, result.Result)
		return nil
	case "$saga_result":
		if err := etf.TermIntoStruct(m.Command, &result); err != nil {
			return ErrUnsupportedRequest
		}
		state.Process.GetObject().(GenSagaBehavior).HandleResult(state, result.Transaction, next, result.Result)
		return nil
	}
	return ErrUnsupportedRequest
}
func handleSagaDown(state *GenSagaState, down DownMessage) error {
	return nil
}
